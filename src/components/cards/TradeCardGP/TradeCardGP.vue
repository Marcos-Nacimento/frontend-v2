<template>
  <BalCard class="relative">
    <template v-slot:header>
      <div class="w-full flex items-center justify-between">
        <h4 class="font-bold">{{ title }}</h4>
        <TradeSettingsPopover :context="TradeSettingsContext.trade" />
      </div>
    </template>
    <div>
      <TradePairGP
        :token-in-amount-input="tokenInAmount"
        :token-in-address-input="tokenInAddress"
        :token-out-amount-input="tokenOutAmount"
        :token-out-address-input="tokenOutAddress"
        :exact-in="exactIn"
        @token-in-amount-change="value => (tokenInAmount = value)"
        @token-in-address-change="value => (tokenInAddress = value)"
        @token-out-amount-change="value => (tokenOutAmount = value)"
        @token-out-address-change="value => (tokenOutAddress = value)"
        @exact-in-change="value => (exactIn = value)"
      />
      <BalAlert
        v-if="error"
        class="mb-4"
        type="error"
        size="sm"
        :title="error.header"
        :description="error.body"
        :action-label="error.label"
        block
        @actionClick="handleErrorButtonClick"
      />
      <BalBtn
        :label="$t('previewTrade')"
        :disabled="tradeDisabled"
        :loading-label="$t('confirming')"
        color="gradient"
        block
        @click.prevent="modalTradePreviewIsOpen = true"
      />
    </div>
    <SuccessOverlay
      v-if="tradeSuccess"
      :title="$t('tradeSettled')"
      :description="$t('tradeSuccess')"
      :closeLabel="$t('close')"
      :explorerLink="explorerLink"
      @close="onSuccessOverlayClose"
    />
  </BalCard>
  <teleport to="#modal">
    <TradePreviewModalGP
      v-if="modalTradePreviewIsOpen"
      :trading="trading"
      :order-id="orderId"
      :order="order"
      @trade="trade"
      @close="modalTradePreviewIsOpen = false"
    />
  </teleport>
</template>

<script lang="ts">
import { ref, defineComponent, computed, watch } from 'vue';
import { useStore } from 'vuex';
import { useRouter } from 'vue-router';
import BigNumber from 'bignumber.js';

import { useI18n } from 'vue-i18n';
import { isAddress, getAddress } from '@ethersproject/address';
import { formatUnits } from '@ethersproject/units';

import { FeeInformation, OrderMetaData } from '@/services/gnosis/types';
import {
  signOrder,
  UnsignedOrder,
  calculateValidTo
} from '@/services/gnosis/signing';
import { OrderKind } from '@gnosis.pm/gp-v2-contracts';
import {
  isOrderFinalized,
  normalizeTokenAddress
} from '@/services/gnosis/utils';

import useTokens from '@/composables/useTokens';
import useNotify from '@/composables/useNotify';
import useAuth from '@/composables/useAuth';
import useGnosisProtocol from '@/composables/useGnosisProtocol';
import useValidation, {
  TradeValidation
} from '@/composables/trade/useValidation';
import SuccessOverlay from '@/components/cards/SuccessOverlay.vue';
import useWeb3 from '@/composables/useWeb3';
import useTokenApprovalGP from '@/composables/trade/useTokenApprovalGP';

import { ETHER } from '@/constants/tokenlists';

import { bnum, scale } from '@/lib/utils';
import { isRequired } from '@/lib/utils/validations';
import { unwrap, wrap } from '@/lib/utils/balancer/wrapper';

import TradePreviewModalGP from '@/components/modals/TradePreviewModalGP.vue';
import TradeSettingsPopover, {
  TradeSettingsContext
} from '@/components/popovers/TradeSettingsPopover.vue';

import TradePairGP from './TradePairGP.vue';
import useNumbers from '@/composables/useNumbers';

// TODO: get app id
const GNOSIS_APP_ID = 2;

const appData = '0x' + GNOSIS_APP_ID.toString(16).padStart(64, '0');

export default defineComponent({
  components: {
    SuccessOverlay,
    TradePairGP,
    TradePreviewModalGP,
    TradeSettingsPopover
  },

  setup() {
    // COMPOSABLES
    const store = useStore();
    const router = useRouter();
    const auth = useAuth();
    const { account, blockNumber, explorer } = useWeb3();
    const { txListener } = useNotify();
    const { t } = useI18n();
    const { gnosisOperator, gnosisExplorer } = useGnosisProtocol();
    const { fNum, toFiat } = useNumbers();

    // DATA
    const exactIn = ref(true);
    const feeQuote = ref<FeeInformation | null>(null);
    const feeExceedsPrice = ref(false);
    const orderId = ref('');
    const orderMetadata = ref<OrderMetaData | null>(null);
    const updatingQuotes = ref(false);
    const latestTxHash = ref('');
    const txHash = ref('');
    const tokenInAddress = ref('');
    const tokenInAmount = ref('');
    const tokenOutAddress = ref('');
    const tokenOutAmount = ref('');
    const maximumInAmountScaled = ref('');
    const minimumOutAmountScaled = ref('');
    const tradeSuccess = ref(false);
    const trading = ref(false);
    const modalTradePreviewIsOpen = ref(false);

    // COMPUTED
    // TODO use web3 composable
    const getConfig = () => store.getters['web3/getConfig']();
    const { allTokensIncludeEth: tokens } = useTokens();
    const slippageBufferRate = computed(() =>
      parseFloat(store.state.app.slippage)
    );

    const tokenIn = computed(() => tokens.value[tokenInAddress.value]);
    const tokenOut = computed(() => tokens.value[tokenOutAddress.value]);

    const isWrap = computed(() => {
      const config = getConfig();
      return (
        tokenInAddress.value === ETHER.address &&
        tokenOutAddress.value === config.addresses.weth
      );
    });

    const isUnwrap = computed(() => {
      const config = getConfig();
      return (
        tokenOutAddress.value === ETHER.address &&
        tokenInAddress.value === config.addresses.weth
      );
    });

    const explorerLink = computed(() =>
      orderId.value != ''
        ? gnosisExplorer.orderLink(orderId.value)
        : explorer.txLink(txHash.value)
    );

    const feeAmountInTokenScaled = computed(
      () => feeQuote.value?.amount ?? '0'
    );
    const feeAmountOutTokenScaled = computed(() =>
      tokenOutAmountScaled.value
        .div(tokenInAmountScaled.value)
        .times(feeAmountInTokenScaled.value)
        .toString()
    );

    const feeAmountInToken = computed(() =>
      formatUnits(feeAmountInTokenScaled.value, tokenIn.value.decimals)
    );

    const feeAmountOutToken = computed(() =>
      formatUnits(feeAmountOutTokenScaled.value, tokenOut.value.decimals)
    );

    const tradeDisabled = computed(() => {
      if (errorMessage.value !== TradeValidation.VALID || feeExceedsPrice.value)
        return true;
      return false;
    });

    useTokenApprovalGP(tokenInAddress, tokenInAmount, tokens);

    const {
      errorMessage,
      isValidTokenAmount,
      tokensAmountsValid
    } = useValidation(
      tokenInAddress,
      tokenInAmount,
      tokenOutAddress,
      tokenOutAmount,
      tokens
    );

    const title = computed(() => {
      if (isWrap.value) return t('wrap');
      if (isUnwrap.value) return t('unwrap');
      return t('tradeGasless');
    });

    const isEthTrade = computed(() => tokenInAddress.value === ETHER.address);

    const appTransactionDeadline = computed<number>(
      () => store.state.app.transactionDeadline
    );

    const orderKind = computed(
      () => (exactIn.value ? OrderKind.SELL : OrderKind.BUY) as OrderKind
    );

    const order = computed(() => ({
      exactIn: exactIn.value,
      tokenIn: tokenIn.value,
      tokenOut: tokenOut.value,
      amountIn: tokenInAmount.value,
      amountOut: tokenOutAmount.value,
      amountOutFormatted: fNum(tokenOutAmount.value, 'token'),
      amountInFormatted: fNum(tokenInAmount.value, 'token'),
      valueIn: toFiat(tokenInAmount.value, tokenInAddress.value),
      valueOut: toFiat(tokenOutAmount.value, tokenOutAddress.value),
      isEthTrade: isEthTrade.value,
      isWrap: isWrap.value,
      isUnwrap: isUnwrap.value,
      tokenInAddress: tokenInAddress.value,
      tokenOutAddress: tokenOutAddress.value,
      effectivePriceMessage: {
        tokenIn: tokensAmountsValid.value
          ? `1 ${tokenIn.value.symbol} = ${fNum(
              tokenOutAmountScaled.value
                .div(tokenInAmountScaled.value)
                .toString(),
              'token'
            )} ${tokenOut.value.symbol}`
          : '',
        tokenOut: tokensAmountsValid
          ? `1 ${tokenOut.value.symbol} = ${fNum(
              tokenInAmountScaled.value
                .div(tokenOutAmountScaled.value)
                .toString(),
              'token'
            )} ${tokenIn.value.symbol}`
          : ''
      },
      minimumOutAmountScaled: minimumOutAmountScaled.value,
      maximumInAmountScaled: maximumInAmountScaled.value,
      feeAmountOutToken: feeAmountOutToken.value,
      feeAmountInToken: feeAmountInToken.value,
      requiresApproval: !(isWrap.value || isUnwrap.value || isEthTrade)
    }));

    const error = computed(() => {
      if (feeExceedsPrice.value) {
        return {
          header: 'Low amount',
          body: 'Fees exceeds from amount'
        };
      }
      switch (errorMessage.value) {
        case TradeValidation.NO_ETHER:
          return {
            header: t('noEth'),
            body: t('noEthDetailed')
          };
        case TradeValidation.NO_BALANCE:
          return {
            header: t('insufficientBalance'),
            body: t('insufficientBalanceDetailed')
          };
        case TradeValidation.NO_LIQUIDITY:
          return {
            header: t('insufficientLiquidity'),
            body: t('insufficientLiquidityDetailed')
          };
        default:
          return undefined;
      }
    });

    const tokenInAmountScaled = computed(() =>
      scale(bnum(tokenInAmount.value), tokenIn.value.decimals)
    );

    const tokenOutAmountScaled = computed(() =>
      scale(bnum(tokenOutAmount.value), tokenOut.value.decimals)
    );

    // METHODS
    function handleErrorButtonClick() {
      console.log('TOOD: implement if needed');
    }

    async function populateInitialTokens(): Promise<void> {
      let assetIn = router.currentRoute.value.params.assetIn as string;
      if (assetIn === ETHER.deeplinkId) assetIn = ETHER.address;
      else if (isAddress(assetIn)) assetIn = getAddress(assetIn);
      let assetOut = router.currentRoute.value.params.assetOut as string;
      if (assetOut === ETHER.deeplinkId) assetOut = ETHER.address;
      else if (isAddress(assetOut)) assetOut = getAddress(assetOut);

      tokenInAddress.value = assetIn || store.state.trade.inputAsset;
      tokenOutAddress.value = assetOut || store.state.trade.outputAsset;
    }

    function onSuccessOverlayClose() {
      tradeSuccess.value = false;
      orderMetadata.value = null;
      txHash.value = '';
      orderId.value = '';
    }

    async function handleETH(action: 'wrap' | 'unwrap') {
      try {
        trading.value = true;

        const { chainId } = getConfig();

        const fn = action === 'wrap' ? wrap : unwrap;
        const tx = await fn(chainId, auth.web3, tokenInAmountScaled.value);
        tradeTxListener(tx.hash);
      } catch (e) {
        console.log(e);
        trading.value = false;
      }
    }

    async function postSignedOrder() {
      try {
        trading.value = true;

        const unsignedOrder: UnsignedOrder = {
          sellToken: normalizeTokenAddress(tokenInAddress.value),
          buyToken: normalizeTokenAddress(tokenOutAddress.value),
          sellAmount: bnum(
            exactIn.value
              ? tokenInAmountScaled.value
              : maximumInAmountScaled.value
          )
            .minus(feeAmountInTokenScaled.value)
            .toString(),
          buyAmount: exactIn.value
            ? minimumOutAmountScaled.value.toString()
            : tokenOutAmountScaled.value.toString(),
          validTo: calculateValidTo(appTransactionDeadline.value),
          appData,
          feeAmount: feeAmountInTokenScaled.value,
          kind: orderKind.value,
          receiver: account.value,
          partiallyFillable: false // Always fill or kill
        };

        const signer = auth.web3.getSigner();

        const { signature, signingScheme } = await signOrder(
          unsignedOrder,
          signer
        );

        orderId.value = await gnosisOperator.postSignedOrder({
          order: {
            ...unsignedOrder,
            signature,
            receiver: account.value,
            signingScheme
          },
          owner: account.value
        });
      } catch (e) {
        console.log(e);
        trading.value = false;
      }
    }

    async function trade() {
      if (isWrap.value) {
        handleETH('wrap');
      } else if (isUnwrap.value) {
        handleETH('unwrap');
      } else {
        postSignedOrder();
      }
    }

    function tradeTxListener(hash: string) {
      txListener(hash, {
        onTxConfirmed: () => {
          trading.value = false;
          latestTxHash.value = hash;
        },
        onTxCancel: () => {
          trading.value = false;
        },
        onTxFailed: () => {
          trading.value = false;
        }
      });
    }

    async function updateQuotes() {
      if (
        isValidTokenAmount(
          exactIn.value ? tokenInAmount.value : tokenOutAmount.value
        )
      ) {
        const sellToken = tokenInAddress.value;
        const buyToken = tokenOutAddress.value;
        const kind = orderKind.value;
        const amountToExchange = exactIn.value
          ? tokenInAmountScaled.value
          : tokenOutAmountScaled.value;

        updatingQuotes.value = true;
        feeExceedsPrice.value = false;

        try {
          const queryParams = {
            sellToken,
            buyToken,
            amount: amountToExchange.toString(),
            kind
          };
          // TODO: there is a chance to optimize here and not make a new request if the fee is not expired
          const feeQuoteResult = await gnosisOperator.getFeeQuote(queryParams);

          if (feeQuoteResult != null) {
            if (exactIn.value) {
              feeExceedsPrice.value = amountToExchange
                .minus(feeQuoteResult.amount)
                .isNegative();
            }
            if (!feeExceedsPrice.value) {
              const priceQuoteResult = await gnosisOperator.getPriceQuote(
                queryParams
              );

              if (priceQuoteResult != null && priceQuoteResult.amount != null) {
                feeQuote.value = feeQuoteResult;

                if (exactIn.value) {
                  tokenOutAmount.value = formatUnits(
                    priceQuoteResult.amount,
                    tokenOut.value.decimals
                  );

                  minimumOutAmountScaled.value = tokenOutAmountScaled.value
                    .minus(feeAmountOutTokenScaled.value)
                    .div(1 + slippageBufferRate.value)
                    .integerValue(BigNumber.ROUND_DOWN)
                    .toString();
                } else {
                  maximumInAmountScaled.value = tokenInAmountScaled.value
                    .plus(feeAmountInTokenScaled.value)
                    .times(1 + slippageBufferRate.value)
                    .integerValue(BigNumber.ROUND_DOWN)
                    .toString();

                  tokenInAmount.value = formatUnits(
                    priceQuoteResult.amount,
                    tokenIn.value.decimals
                  );
                }
              }
            }
          }
        } catch (e) {
          console.log('[Gnosis Quotes] Failed to update quotes', e);
        }
        updatingQuotes.value = false;
      }
    }

    // WATCHERS
    watch(tokenInAddress, async () => {
      store.commit('trade/setInputAsset', tokenInAddress.value);
      feeQuote.value = null;
      updateQuotes();
    });

    watch(tokenOutAddress, async () => {
      store.commit('trade/setOutputAsset', tokenOutAddress.value);
      feeQuote.value = null;
      updateQuotes();
    });

    watch(tokenInAmount, () => {
      if (tokenInAmount.value !== '') {
        updateQuotes();
      } else {
        tokenOutAmount.value = '';
      }
    });

    watch(tokenOutAmount, async () => {
      if (tokenOutAmount.value !== '') {
        updateQuotes();
      } else {
        tokenInAmount.value = '';
      }
    });

    watch(blockNumber, async () => {
      updateQuotes();

      if (orderId.value != '') {
        const order = await gnosisOperator.getOrder(orderId.value);
        if (isOrderFinalized(order)) {
          orderMetadata.value = order;
          trading.value = false;
          tradeSuccess.value = true;
          modalTradePreviewIsOpen.value = false;
        }
      }
    });

    watch(latestTxHash, () => {
      txHash.value = latestTxHash.value;
      tradeSuccess.value = true;
      modalTradePreviewIsOpen.value = false;
    });

    // INIT
    populateInitialTokens();

    return {
      // context
      TradeSettingsContext,

      // data
      tokenInAddress,
      tokenInAmount,
      tokenOutAddress,
      tokenOutAmount,
      txHash,
      modalTradePreviewIsOpen,
      exactIn,
      orderId,

      // computed
      explorerLink,
      title,
      error,
      errorMessage,
      isRequired,
      tradeDisabled,
      trading,
      tradeSuccess,
      order,

      // methods
      handleErrorButtonClick,
      updatingQuotes,
      trade,
      onSuccessOverlayClose
    };
  }
});
</script>
